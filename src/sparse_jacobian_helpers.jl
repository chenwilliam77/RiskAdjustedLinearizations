# Helper functions for exploiting sparsity in the Jacobians of Œº, Œæ, and ùí±

"""
```
compute_sparsity_pattern(f::Function, x::AbstractVector{<: Number}, nrow::Int;
                         sparsity::Union{AbstractArray, Nothing} = nothing,
                         sparsity_detection::Bool = false)
```
calculates the sparsity pattern of the Jacobian of the functions Œº, Œæ, and ùí±.

### Inputs
- `f`: is the function to be differentiated, e.g. `z -> ùí±(z, Œ®, (1, 2))`
- `x`: the vector at which differentiation occurs
- `nrow`: specifies the number of rows of the Jacobian

### Keywords
- `sparsity`: sparsity pattern of the Jacobian
- `sparsity_detection`: if true, use SparsityDetection.jl to determine the sparsity pattern.
    If false, then the sparsity pattern is determined by using automatic differentiation
    to calculate a Jacobian and assuming any zeros are supposed to be zero.
"""
function compute_sparsity_pattern(f::Function, x::AbstractVector{T}, nrow::Int;
                                  sparsity::Union{AbstractArray, Nothing} = nothing,
                                  sparsity_detection::Bool = false) where {T <: Number}

    if isnothing(sparsity)
        sparsity = if sparsity_detection
            convert(SparseMatrixCSC{eltype(x), Int}, jacobian_sparsity(f, similar(x, nrow), x))
        else
            sparse(ForwardDiff.jacobian(f, x))
        end
    end

    if isempty(nonzeros(sparsity))
        # default to differentiating a dense matrix if all zeros
        return sparse(ones(T, size(sparsity))), 1:length(x)
    else
        return sparsity, matrix_colors(sparsity)
    end
end

"""
```
update_sparsity_pattern!(m::RiskAdjustedLinearization, function_name::Union{Symbol, Vector{Symbol}};
                         z::AbstractVector{<: Number} = m.z,
                         y::AbstractVector{<: Number} = m.y,
                         Œ®::AbstractVector{<: Number} = m.Œ®,
                         sparsity::AbstractDict{Symbol, AbstractMatrix} = Dict{Symbol, AbstractMatrix}(),
                         colorvec::AbstractDict{Symbol, <: AbstractVector{Int}} = Dict{Symbol, Vector{Int}}(),
                         sparsity_detection::Bool = false)
```
updates the Jacobians of Œº, Œæ, and/or ùí± in `m` with a new sparsity pattern. The Jacobians
to be updated are specified by `function_name`, e.g. `function_name = [:Œº, :Œæ, :ùí±]`.

If the keyword `sparsity` is empty, then the function attempts to determine the new sparsity pattern by computing
the Jacobian via automatic differentiation and assuming any zeros are supposed to be zero.
Keywords provide guesses for the coefficients ``(z, y, \\Psi)`` that are required
to calculate the Jacobians.

### Keywords
- `z`: state coefficients at steady state
- `y`: jump coefficients at steady state
- `Œ®`: coefficients for mapping from states to jumps
- `sparsity`: key-value pairs can be used to specify new sparsity patterns for the Jacobian functions
    `Œºz`, `Œºy`, `Œæz`, `Œæy`, and `Jùí± `.
- `colorvec`: key-value pairs can be used to specify new matrix coloring vectors for the Jacobian functions
    `Œºz`, `Œºy`, `Œæz`, `Œæy`, and `Jùí± `.
- `sparsity_detection`: use SparsityDetection.jl to determine the sparsity pattern.
"""
function update_sparsity_pattern!(m::RiskAdjustedLinearization, function_name::Symbol;
                                  z::AbstractVector{<: Number} = m.z,
                                  y::AbstractVector{<: Number} = m.y,
                                  Œ®::AbstractMatrix{<: Number} = m.Œ®,
                                  sparsity::AbstractDict = Dict{Symbol, Matrix}(),
                                  colorvec::AbstractDict = Dict{Symbol, Vector{Int}}(),
                                  sparsity_detection::Bool = false)
    return update_sparsity_pattern!(m, [function_name]; z = z, y = y, Œ® = Œ®,
                                    sparsity = sparsity, colorvec = colorvec,
                                    sparsity_detection = sparsity_detection)
end

function update_sparsity_pattern!(m::RiskAdjustedLinearization, function_names::Vector{Symbol};
                                  z::AbstractVector{<: Number} = m.z,
                                  y::AbstractVector{<: Number} = m.y,
                                  Œ®::AbstractMatrix{<: Number} = m.Œ®,
                                  sparsity::AbstractDict = Dict{Symbol, Matrix}(),
                                  colorvec::AbstractDict = Dict{Symbol, Vector{Int}}(),
                                  sparsity_detection::Bool = false)

    if :Œº in function_names
        Œºz, Œºy, Œºz_jac_cache, Œºy_jac_cache =
            construct_Œº_jacobian_function(m.nonlinear.Œº, z, y;
                                          sparsity_z = haskey(sparsity, :Œºz) ? sparsity[:Œºz] : nothing,
                                          sparsity_y = haskey(sparsity, :Œºy) ? sparsity[:Œºy] : nothing,
                                          colorvec_z = haskey(colorvec, :Œºz) ? colorvec[:Œºz] : nothing,
                                          colorvec_y = haskey(colorvec, :Œºy) ? colorvec[:Œºy] : nothing,
                                          sparsity_detection = sparsity_detection)

        m.linearization.Œºz = Œºz
        m.linearization.Œºy = Œºy
        m.linearization.sparse_jac_caches[:Œºz] = Œºz_jac_cache
        m.linearization.sparse_jac_caches[:Œºy] = Œºy_jac_cache
    end

    if :Œæ in function_names
        Œæz, Œæy, Œæz_jac_cache, Œæy_jac_cache =
            construct_Œæ_jacobian_function(m.nonlinear.Œæ, z, y;
                                          sparsity_z = haskey(sparsity, :Œæz) ? sparsity[:Œæz] : nothing,
                                          sparsity_y = haskey(sparsity, :Œæy) ? sparsity[:Œæy] : nothing,
                                          colorvec_z = haskey(colorvec, :Œæz) ? colorvec[:Œæz] : nothing,
                                          colorvec_y = haskey(colorvec, :Œæy) ? colorvec[:Œæy] : nothing,
                                          sparsity_detection = sparsity_detection)

        m.linearization.Œæz = Œæz
        m.linearization.Œæy = Œæy
        m.linearization.sparse_jac_caches[:Œæz] = Œæz_jac_cache
        m.linearization.sparse_jac_caches[:Œæy] = Œæy_jac_cache
    end

    if :ùí± in function_names
        Jùí±, Jùí±_jac_cache = if isa(m.nonlinear.ùí±, RALF2)
            construct_ùí±_jacobian_function(m.nonlinear.ùí±, m.nonlinear.ccgf, m.nonlinear.Œõ, m.nonlinear.Œ£,
                                          m[:Œì‚ÇÖ], m[:Œì‚ÇÜ], z, Œ®;
                                          sparsity = haskey(sparsity, :Jùí±) ? sparsity[:Jùí±] : nothing,
                                          colorvec = haskey(colorvec, :Jùí±) ? colorvec[:Jùí±] : nothing,
                                          sparsity_detection = sparsity_detection)
        else
            construct_ùí±_jacobian_function(m.nonlinear.ùí±, m.nonlinear.ccgf, m.nonlinear.Œõ, m.nonlinear.Œ£,
                                          m[:Œì‚ÇÖ], m[:Œì‚ÇÜ], z, y, Œ®; sparsity = haskey(sparsity, :Jùí±) ? sparsity[:Jùí±] : nothing,
                                          colorvec = haskey(colorvec, :Jùí±) ? colorvec[:Jùí±] : nothing,
                                          sparsity_detection = sparsity_detection)
        end

        m.linearization.Jùí± = Jùí±
        m.linearization.sparse_jac_caches[:Jùí±] = Jùí±_jac_cache
    end

    m
end

## Helper functions for constructing the Jacobian functions of Œº, Œæ, and ùí±
function construct_Œº_jacobian_function(Œº::RALF2, z::AbstractVector{T}, y::AbstractVector{T};
                                       sparsity_z::Union{AbstractArray, Nothing} = nothing,
                                       sparsity_y::Union{AbstractArray, Nothing} = nothing,
                                       colorvec_z = nothing, colorvec_y = nothing,
                                       sparsity_detection::Bool = false) where {T <: Number}

    # Define (temporary) objective functions
    _f_Œºz = z -> Œº(z, y, (1, 2))
    _f_Œºy = y -> Œº(z, y, (2, 3))

    # Infer sparsity patterns and matrix coloring vector
    Nz = length(z)
    if isnothing(sparsity_z)
        sparsity_z, colorvec_z = compute_sparsity_pattern(_f_Œºz, z, Nz; sparsity_detection = sparsity_detection)
    elseif isnothing(colorvec_z)
        colorvec_z = matrix_colors(sparsity_z)
    end
    if isnothing(sparsity_y)
        sparsity_y, colorvec_y = compute_sparsity_pattern(_f_Œºy, y, Nz; sparsity_detection = sparsity_detection)
    elseif isnothing(colorvec_y)
        colorvec_y = matrix_colors(sparsity_y)
    end

    #=        # Create caches for the sparse Jacobian methods # This code is left here for when
    jac_cache_Œºz = ForwardColorJacCache(_f_Œºz, z, min(m.Nz, m.Ny); # Jacobians of Œº and Œæ are refactored
    sparsity = sparsity_Œºz, colorvec = colorvec_Œºz)
    jac_cache_Œºy = ForwardColorJacCache(_f_Œºy, y, min(m.Nz, m.Ny);
    sparsity = sparsity_Œºy, colorvec = colorvec_Œºy)=#

    # Create RALF2 objects. Note that we cannot pre-allocate the caches for
    # forwarddiff_color_jacobian! by using ForwardColorJacCache b/c the objective function
    # changes as z and y change. If Jacobians of Œº and Œæ are refactored to be done once,
    # then it'll be possible to cache.
    Œº_dz = similar(z)
    Œº_dy = similar(z)

    Œºz = RALF2((F, z, y) -> forwarddiff_color_jacobian!(F, (F0, x) -> Œº.f0(F0, x, y), z, dx = Œº_dz,
                                                        colorvec = colorvec_z, sparsity = sparsity_z),
               z, y, deepcopy(sparsity_z))
    Œºy = RALF2((F, z, y) -> forwarddiff_color_jacobian!(F, (F0, x) -> Œº.f0(F0, z, x), y, dx = Œº_dy,
                                                        colorvec = colorvec_y, sparsity = sparsity_y),
               z, y, deepcopy(sparsity_y))

    # Create mini-version of the Jacobian cache
    Œºz_jac_cache = (dx = Œº_dz, sparsity = sparsity_z, colorvec = colorvec_z)
    Œºy_jac_cache = (dx = Œº_dy, sparsity = sparsity_y, colorvec = colorvec_y)

    return Œºz, Œºy, Œºz_jac_cache, Œºy_jac_cache
end

function construct_Œæ_jacobian_function(Œæ::RALF2, z::AbstractVector{T}, y::AbstractVector{T};
                                       sparsity_z::Union{AbstractArray, Nothing} = nothing,
                                       sparsity_y::Union{AbstractArray, Nothing} = nothing,
                                       colorvec_z = nothing, colorvec_y = nothing,
                                       sparsity_detection::Bool = false) where {T <: Number}

    # Define (temporary) objective functions
    _f_Œæz = z -> Œæ(z, y, (1, 2))
    _f_Œæy = y -> Œæ(z, y, (2, 3))

    # Infer sparsity patterns and matrix coloring vector
    Ny = length(y)
    if isnothing(sparsity_z)
        sparsity_z, colorvec_z = compute_sparsity_pattern(_f_Œæz, z, Ny; sparsity_detection = sparsity_detection)
    elseif isnothing(colorvec_z)
        colorvec_z = matrix_colors(sparsity_z)
    end
    if isnothing(sparsity_y)
        sparsity_y, colorvec_y = compute_sparsity_pattern(_f_Œæy, y, Ny; sparsity_detection = sparsity_detection)
    elseif isnothing(colorvec_y)
        colorvec_y = matrix_colors(sparsity_y)
    end

    #=        # Create caches for the sparse Jacobian methods # This code is left here for when
    jac_cache_Œæz = ForwardColorJacCache(_f_Œæz, z, min(m.Nz, m.Ny);
    sparsity = sparsity_Œæz, colorvec = colorvec_Œæz)
    jac_cache_Œæy = ForwardColorJacCache(_f_Œæy, y, min(m.Nz, m.Ny);
    sparsity = sparsity_Œæy, colorvec = colorvec_Œæy)=#

    # Create RALF2 objects. Note that we cannot pre-allocate the caches for
    # forwarddiff_color_jacobian! by using ForwardColorJacCache b/c the objective function
    # changes as z and y change. If Jacobians of Œº and Œæ are refactored to be done once,
    # then it'll be possible to cache.
    Œæ_dz = similar(y)
    Œæ_dy = similar(y)

    Œæz = RALF2((F, z, y) -> forwarddiff_color_jacobian!(F, (F0, x) -> Œæ.f0(F0, x, y), z, dx = Œæ_dz,
                                                        colorvec = colorvec_z, sparsity = sparsity_z),
               z, y, deepcopy(sparsity_z))
    Œæy = RALF2((F, z, y) -> forwarddiff_color_jacobian!(F, (F0, x) -> Œæ.f0(F0, z, x), y, dx = Œæ_dy,
                                                        colorvec = colorvec_y, sparsity = sparsity_y),
               z, y, deepcopy(sparsity_y))

    # Create mini-version of the Jacobian cache
    Œæz_jac_cache = (dx = Œæ_dz, sparsity = sparsity_z, colorvec = colorvec_z)
    Œæy_jac_cache = (dx = Œæ_dy, sparsity = sparsity_y, colorvec = colorvec_y)

    return Œæz, Œæy, Œæz_jac_cache, Œæy_jac_cache
end

function construct_ùí±_jacobian_function(ùí±::RALF2, ccgf::Function, Œõ::RALF1, Œ£::RALF1{LC}, Œì‚ÇÖ::AbstractArray{<: Number},
                                       Œì‚ÇÜ::AbstractArray{<: Number}, z::AbstractVector{T}, Œ®::AbstractMatrix{T};
                                       sparsity::Union{AbstractArray, Nothing} = nothing,
                                       colorvec = nothing, sparsity_detection::Bool = false) where {T <: Number, LC}

    # Define (temporary) objective functions
    _f_ùí±z = z -> ùí±(z, Œ®, (1, 2))

    # Need to grab some dimensions
    Ny, Nz = size(Œ®)
    NŒµ     = size(LC <: AbstractArray ? Œ£.cache : Œ£.cache.du, 2)

    # Infer sparsity patterns and matrix coloring vector
    if isnothing(sparsity)
        sparsity, colorvec = compute_sparsity_pattern(_f_ùí±z, z, Ny; sparsity_detection = sparsity_detection)
    elseif isnothing(colorvec)
        colorvec = matrix_colors(sparsity)
    end

    # Create RALF2 object. Note that we cannot pre-allocate the caches for
    # forwarddiff_color_jacobian! by using ForwardColorJacCache b/c the objective function
    # changes as the coefficients (z, y, Œ®) change.
    #
    # For ùí± specifically, to avoid problems reinterpreting arrays to make autodiff work,
    # we redefine the ùí± function to use Œõ.f0 and Œ£.f0 rather than using the RALF objects
    # (as we do when applying autodiff for dense Jacobians). If we use Œõ(z) and Œ£(z)
    # directly, then the reinterpret step may either fail (cannot reinterpret the array
    # to the new desired chunk size), or the reinterpreted array
    # will have the wrong dimensions.

    ## Infer whether Œõ and Œ£ are in place
    FŒõ0 = similar(z, Nz, Ny)
    FŒ£0 = similar(z, Nz, NŒµ)
    Œõ0 = if applicable(Œõ.f0, FŒõ0, z)
        Œõ.f0
    else
        function _Œõ_op(F, z)
            F .= Œõ.f0(z)
        end
    end
    Œ£0 = if applicable(Œ£.f0, FŒõ0, z)
        Œ£.f0
    else
        function _Œ£_op(F, z)
            F .= Œ£.f0(z)
        end
    end

    _ùí±_sparse = if applicable(ccgf, Œì‚ÇÖ, z)
        function _ùí±_sparse_op(F, z, Œ®)
            FŒõ = similar(F, Nz, Ny)
            FŒ£ = similar(F, Nz, NŒµ)
            Œõ0(FŒõ, z)
            Œ£0(FŒ£, z)
            F .= ccgf((Œì‚ÇÖ + Œì‚ÇÜ * Œ®) * ((I - (FŒõ * Œ®)) \ FŒ£), z)
        end
    else
        function _ùí±_sparse_ip(F, z, Œ®)
            FŒõ = similar(F, Nz, Ny)
            FŒ£ = similar(F, Nz, NŒµ)
            Œõ0(FŒõ, z)
            Œ£0(FŒ£, z)
            ccgf(F, (Œì‚ÇÖ + Œì‚ÇÜ * Œ®) * ((I - (FŒõ * Œ®)) \ FŒ£), z)
        end
    end
    ùí±_dz = similar(z, Ny)

    Jùí± = RALF2((F, z, Œ®) -> forwarddiff_color_jacobian!(F, (F0, x) -> _ùí±_sparse(F0, x, Œ®), z, dx = ùí±_dz,
                                                        colorvec = colorvec, sparsity = sparsity),
               z, Œ®, deepcopy(sparsity))

    # Create mini-version of the Jacobian cache
    Jùí±_jac_cache = (dx = ùí±_dz, sparsity = sparsity, colorvec = colorvec)

    return Jùí±, Jùí±_jac_cache
end

function construct_ùí±_jacobian_function(ùí±::RALF4, ccgf::Function, Œõ::RALF2, Œ£::RALF2{LC}, Œì‚ÇÖ::AbstractArray{<: Number},
                                       Œì‚ÇÜ::AbstractArray{<: Number}, z::AbstractVector{T}, y::AbstractVector{T},
                                       Œ®::AbstractMatrix{T};
                                       sparsity::Union{AbstractArray, Nothing} = nothing,
                                       colorvec = nothing, sparsity_detection::Bool = false) where {T <: Number, LC}

    # Define (temporary) objective functions
    _f_ùí±z = z‚Çú -> ùí±(z‚Çú, y, Œ®, z‚Çú, (4, 2))

    # Need to grab some dimensions
    Ny, Nz = size(Œ®)
    NŒµ     = size(LC <: AbstractArray ? Œ£.cache : Œ£.cache.du, 2)

    # Infer sparsity patterns and matrix coloring vector
    if isnothing(sparsity)
        sparsity, colorvec = compute_sparsity_pattern(_f_ùí±z, z, Ny; sparsity_detection = sparsity_detection)
    elseif isnothing(colorvec)
        colorvec = matrix_colors(sparsity)
    end

    # Create RALF2 objects. Note that we cannot pre-allocate the caches for
    # forwarddiff_color_jacobian! by using ForwardColorJacCache b/c the objective function
    # changes as z and y change. If Jacobians of Œº and Œæ are refactored to be done once,
    # then it'll be possible to cache.
    #
    # See the previous version of construct_ùí±_jacobian_function for comments on
    # why we re-implement ùí± as done below.

    FŒõ0 = similar(z, Nz, Ny)
    FŒ£0 = similar(z, Nz, NŒµ)
    Œõ0 = if applicable(Œõ.f0, FŒõ0, z, y)
        Œõ.f0
    else
        function _Œõ_op(F, z, y)
            F .= Œõ.f0(z, y)
        end
    end
    Œ£0 = if applicable(Œ£.f0, FŒõ0, z, y)
        Œ£.f0
    else
        function _Œ£_op(F, z, y)
            F .= Œ£.f0(z, y)
        end
    end

    _ùí±_sparse = if applicable(ccgf, Œì‚ÇÖ, z)
        function _ùí±_sparse_op(F, z, y, Œ®, z‚Çú)
            FŒõ = similar(F, Nz, Ny)
            FŒ£ = similar(F, Nz, NŒµ)
            y‚Çú = y + Œ® * (z‚Çú - z)
            Œõ0(FŒõ, z‚Çú, y‚Çú)
            Œ£0(FŒ£, z‚Çú, y‚Çú)
            F .= ccgf((Œì‚ÇÖ + Œì‚ÇÜ * Œ®) * ((I - (FŒõ * Œ®)) \ FŒ£), z‚Çú)
        end
    else
        function _ùí±_sparse_ip(F, z, y, Œ®, z‚Çú)
            FŒõ = similar(F, Nz, Ny)
            FŒ£ = similar(F, Nz, NŒµ)
            y‚Çú = y + Œ® * (z‚Çú - z)
            Œõ0(FŒõ, z‚Çú, y‚Çú)
            Œ£0(FŒ£, z‚Çú, y‚Çú)
            ccgf(F, (Œì‚ÇÖ + Œì‚ÇÜ * Œ®) * ((I - (FŒõ * Œ®)) \ FŒ£), z‚Çú)
        end
    end

    ùí±_dz = similar(y, Ny)
    Jùí± = RALF3((F, z, y, Œ®) -> forwarddiff_color_jacobian!(F, (F0, z‚Çú) -> _ùí±_sparse(F0, z, y, Œ®, z‚Çú), z, dx = ùí±_dz,
                                                           colorvec = colorvec, sparsity = sparsity),
               z, y, Œ®, deepcopy(sparsity))

    # Create mini-version of the Jacobian cache
    Jùí±_jac_cache = (dx = ùí±_dz, sparsity = sparsity, colorvec = colorvec)

    return Jùí±, Jùí±_jac_cache
end

# Helper functions for exploiting sparsity in calls to nlsolve

## Helper function for compute_sparsity_pattern
function infer_objective_function(m::RiskAdjustedLinearization, algorithm::Symbol; q::Float64 = .1)

    f = if algorithm == :deterministic
        (F, x) -> _deterministic_equations(F, x, m)
    elseif algorithm == :relaxation
        (F, x) -> _relaxation_equations(F, x, m, m.Œ®, m[:ùí±_sss])
    elseif algorithm == :homotopy
        if Œõ_eltype(m.nonlinear) <: RALF1 && Œ£_eltype(m.nonlinear) <: RALF1
            (F, x) -> _homotopy_equations1(F, x, m, q)
        else
            (F, x) -> _homotopy_equations2(F, x, m, q)
        end
    end

    return f
end

"""
```
compute_sparsity_pattern(m::RiskAdjustedLinearization, algorithm::Symbol; q::Float64 = .1,
                         sparsity::Union{AbstractArray, Nothing} = nothing,
                         sparsity_detection::Bool = false)
```
calculates the sparsity pattern and matrix coloring vector of the Jacobian
of the nonlinear system of equations for either the deterministic or
stochastic steady state, depending on which `algorithm` is called.

### Keywords
- `q`: step size for homotopy. Should satisfy `0 < q < 1` and is only required to ensure
    that the sparsity pattern is correctly determined when `algorithm = :homotopy`
    and thus the dependence of the entropy `ùí±` on the coefficients `(z, y, Œ®)` matters.
- `sparsity`: sparsity pattern of the Jacobian of the nonlinear system of equations
- `sparsity_detection`: if true, use SparsityDetection.jl to determine the sparsity pattern.
    If false, then the sparsity pattern is determined by using finite differences
    to calculate a Jacobian and assuming any zeros are supposed to be zero.
"""
function compute_sparsity_pattern(m::RiskAdjustedLinearization, algorithm::Symbol; q::Float64 = .1,
                                  sparsity::Union{AbstractArray, Nothing} = nothing,
                                  sparsity_detection::Bool = false)
    @assert algorithm in [:deterministic, :relaxation, :homotopy] "The algorithm must be :deterministic, :relaxation, or :homotopy"
    @assert 1 > q > 0 "The step size q must satisfy 0 < q < 1."

    f = infer_objective_function(m, algorithm; q = q)

    input = algorithm == :homotopy ? vcat(m.z, m.y, vec(m.Œ®)) : vcat(m.z, m.y)
    if isnothing(sparsity)
        sparsity = if sparsity_detection
            convert(SparseMatrixCSC{eltype(x), Int}, jacobian_sparsity(f, similar(input), input))
        else
            jac = similar(input, length(input), length(input))
            FiniteDiff.finite_difference_jacobian!(jac, f, input)
            sparse(jac)
        end
    end
    colorvec = matrix_colors(sparsity)

    return sparsity, colorvec
end

"""
```
preallocate_jac_cache(m::RiskAdjustedLinearization, algorithm::Symbol; q::Float64 = .1,
                      sparsity::Union{AbstractArray, Nothing} = nothing,
                      sparsity_detection::Bool = false)
```
pre-allocates the cache for the Jacobian of the nonlinear system of equations
for either the deterministic or stochastic steady state, depending on which
`algorithm` is called.

### Keywords
- `q`: step size for homotopy. Should satisfy `0 < q < 1` and is only required to ensure
    that the sparsity pattern is correctly determined when `algorithm = :homotopy`
    and thus the dependence of the entropy `ùí±` on the coefficients `(z, y, Œ®)` matters.
- `sparsity`: the sparsity pattern of the Jacobian of the nonlinear system of equations
- `sparsity_detection`: if true, use SparsityDetection.jl to determine the sparsity pattern.
    If false, then the sparsity pattern is determined by using finite differences
    to calculate a Jacobian and assuming any zeros are supposed to be zero.
"""
function preallocate_jac_cache(m::RiskAdjustedLinearization, algorithm::Symbol; q::Float64 = .1,
                               sparsity::Union{AbstractArray, Nothing} = nothing,
                               sparsity_detection::Bool = false)

    sparsity, colorvec = compute_sparsity_pattern(m, algorithm; q = q,
                                                  sparsity = sparsity, sparsity_detection = sparsity_detection)
    input = algorithm == :homotopy ? vcat(m.z, m.y, vec(m.Œ®)) : vcat(m.z, m.y)

    return FiniteDiff.JacobianCache(input, colorvec = colorvec, sparsity = sparsity)
end

function construct_sparse_jacobian_function(m::RiskAdjustedLinearization, f::Function,
                                            algorithm::Symbol, autodiff::Symbol;
                                            sparsity::Union{AbstractArray, Nothing} = nothing,
                                            colorvec = nothing, jac_cache = nothing,
                                            sparsity_detection::Bool = false)

    if isnothing(jac_cache)
        # Create Jacobian function that does not assume the existence of a cache

        if isnothing(sparsity) # No sparsity pattern provided, so need to make one
            sparsity, colorvec = compute_sparsity_pattern(m, algorithm; sparsity = sparsity,
                                                          sparsity_detection = sparsity_detection)
        elseif isnothing(colorvec) # Sparsity pattern, but no colorvec, so apply matrix_colors
            colorvec = matrix_colors(sparsity)
        end

        nlsolve_jacobian! = if autodiff == :forward
            (F, x) -> forwarddiff_color_jacobian!(F, f, x, # homotopy doesn't work with autodiff, so assuming
                                                  ForwardColorJacCache(f, x, min(m.Nz, m.Ny); # only using deterministic/relaxation,
                                                                       colorvec = colorvec, sparsity = sparsity)) # hence the chunk size
        else
            (F, x) -> FiniteDiff.finite_difference_jacobian!(F, f, x; colorvec = colorvec,
                                                             sparsity = sparsity)
        end

        return nlsolve_jacobian!, sparsity
    else
        # Create Jacobian function that assumes the existence of a cache

        nlsolve_jacobian! = if autodiff == :forward
            (F, x) -> forwarddiff_color_jacobian!(F, f, x, jac_cache)
        else
            (F, x) -> FiniteDiff.finite_difference_jacobian!(F, f, x, jac_cache)
        end

        return nlsolve_jacobian!, jac_cache.sparsity
    end
end

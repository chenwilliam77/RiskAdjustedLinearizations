# Helper functions for exploiting sparsity in the Jacobians of Œº, Œæ, and ùí±

"""
```
compute_sparsity_pattern(f::Function, x::AbstractVector{<: Number};
                         sparsity::Union{AbstractArray, Nothing} = nothing,
                         sparsity_detection::Bool = false)
```
calculates the sparsity pattern of the Jacobian of the functions Œº, Œæ, and ùí±.

### Keywords
- `sparsity`: sparsity pattern of the Jacobian
- `sparsity_detection`: if true, use SparsityDetection.jl to determine the sparsity pattern.
    If false, then the sparsity pattern is determined by using automatic differentiation
    to calculate a Jacobian and assuming any zeros will always be zero.
"""
function compute_sparsity_pattern(f::Function, x::AbstractVector{<: Number};
                                  sparsity::Union{AbstractArray, Nothing} = nothing,
                                  sparsity_detection::Bool = false)

    if isnothing(sparsity)
        sparsity = if sparsity_detection
            jacobian_sparsity(f, similar(input), input)
        else
            sparse(ForwardDiff.jacobian(f, input))
        end
    end
    colorvec = matrix_colors(sparsity)

    return sparsity, colorvec
end

"""
```
update_sparsity_pattern!(m::RiskAdjustedLinearization, function_name::Union{Symbol, Vector{Symbol}};
                         z::AbstractVector{<: Number} = m.z,
                         y::AbstractVector{<: Number} = m.y,
                         Œ®::AbstractVector{<: Number} = m.Œ®,
                         sparsity::AbstractDict{Symbol, AbstractMatrix} = Dict{Symbol, AbstractMatrix}(),
                         colorvec::AbstractDict{Symbol, <: AbstractVector{Int}} = Dict{Symbol, Vector{Int}}(),
                         sparsity_detection::Bool = false)
```
updates the Jacobians of Œº, Œæ, and/or ùí± in the `RiskAdjustedLinearization` `m`
with a new sparsity pattern. If the keyword `sparsity`
is empty, then the function attempts to determine the new sparsity pattern by computing
the Jacobian via automatic differentiation and assuming any zeros are always zero.
Keywords provide guesses for the coefficients ``(z, y, \\Psi)`` that are required
to calculate the Jacobians.

### Keywords
- `z`: state coefficients at steady state
- `y`: jump coefficients at steady state
- `Œ®`: coefficients for mapping from states to jumps
- `sparsity`: key-value pairs can be used to specify new sparsity patterns for the Jacobian functions
    `Œºz`, `Œºy`, `Œæz`, `Œæy`, and `Jùí± `.
- `colorvec`: key-value pairs can be used to specify new matrix coloring vectors for the Jacobian functions
    `Œºz`, `Œºy`, `Œæz`, `Œæy`, and `Jùí± `.
- `sparsity_detection`: use SparsityDetection.jl to determine the sparsity pattern.
"""
function update_sparsity_pattern!(m::RiskAdjustedLinearization, function_name::Symbol;
                                  z::AbstractVector{<: Number} = m.z,
                                  y::AbstractVector{<: Number} = m.y,
                                  Œ®::AbstractVector{<: Number} = m.Œ®,
                                  sparsity::AbstractDict{Symbol, AbstractMatrix} = Dict{Symbol, AbstractMatrix}(),
                                  colorvec::AbstractDict{Symbol, <: AbstractVector{Int}} = Dict{Symbol, Vector{Int}}(),
                                  sparsity_detection::Bool = false)
    return update_sparsity_pattern!(m, [function_name]; z = z, y = y, Œ® = Œ®,
                                    sparsity = sparsity, colorvec = colorvec,
                                    sparsity_detection = sparsity_detection)
end

function update_sparsity_pattern!(m::RiskAdjustedLinearization, function_names::Vector{Symbol};
                                  z::AbstractVector{<: Number} = m.z,
                                  y::AbstractVector{<: Number} = m.y,
                                  Œ®::AbstractVector{<: Number} = m.Œ®,
                                  sparsity::AbstractDict{Symbol, AbstractMatrix} = Dict{Symbol, AbstractMatrix}(),
                                  colorvec::AbstractDict{Symbol, <: AbstractVector{Int}} = Dict{Symbol, Vector{Int}}(),
                                  sparsity_detection::Bool = false)

    if :Œº in function_names
        Œºz, Œºy, Œºz_jac_cache, Œºy_jac_cache =
            construct_Œº_jacobian_function(m.Œº, z, y;
                                          sparsity_z = haskey(sparsity, :Œºz) ? sparsity[:Œºz] : nothing,
                                          sparsity_y = haskey(sparsity, :Œºy) ? sparsity[:Œºy] : nothing,
                                          colorvec_z = haskey(sparsity, :Œºz) ? sparsity[:Œºz] : nothing,
                                          colorvec_y = haskey(sparsity, :Œºy) ? sparsity[:Œºy] : nothing,
                                          sparsity_detection = sparsity_detection)

        m.linearization.Œºz = Œºz
        m.linearization.Œºy = Œºy
        m.linearization.jac_cache[:Œºz] = Œºz_jac_cache
        m.linearization.jac_cache[:Œºy] = Œºy_jac_cache
    end

    if :Œæ in function_names
        Œæz, Œæy, Œæz_jac_cache, Œæy_jac_cache =
            construct_Œæ_jacobian_function(m.Œæ, z, y;
                                          sparsity_z = haskey(sparsity, :Œæz) ? sparsity[:Œæz] : nothing,
                                          sparsity_y = haskey(sparsity, :Œæy) ? sparsity[:Œæy] : nothing,
                                          colorvec_z = haskey(sparsity, :Œæz) ? sparsity[:Œæz] : nothing,
                                          colorvec_y = haskey(sparsity, :Œæy) ? sparsity[:Œæy] : nothing,
                                          sparsity_detection = sparsity_detection)

        m.linearization.Œæz = Œæz
        m.linearization.Œæy = Œæy
        m.linearization.jac_cache[:Œæz] = Œæz_jac_cache
        m.linearization.jac_cache[:Œæy] = Œæy_jac_cache
    end

    if :ùí± in function_names
        Jùí±, Jùí±_jac_cache = if isa(m.nonlinear.ùí±, RALF2)
            construct_ùí±_jacobian_function(m.ùí±, z, Œ®; sparsity = haskey(sparsity, :Jùí±) ? sparsity[:Jùí±] : nothing,
                                          colorvec = haskey(colorvec, :Jùí±) ? colorvec[:Jùí±] : nothing,
                                          sparsity_detection = sparsity_detection)
        else
            construct_ùí±_jacobian_function(m.ùí±, z, y, Œ®; sparsity = haskey(sparsity, :Jùí±) ? sparsity[:Jùí±] : nothing,
                                          colorvec = haskey(colorvec, :Jùí±) ? colorvec[:Jùí±] : nothing,
                                          sparsity_detection = sparsity_detection)
        end

        m.linearization.Jùí± = Jùí±
        m.linearization.jac_cache[:Jùí±] = Jùí±_jac_cache
    end

    m
end

function construct_Œº_jacobian_function(Œº::RALF2, z::AbstractVector{<: Number}, y::AbstractVector{<: Number};
                                       sparsity_z::Union{AbstractArray, Nothing} = nothing,
                                       sparsity_y::Union{AbstractArray, Nothing} = nothing,
                                       colorvec_z = nothing, colorvec_y = nothing,
                                       sparsity_detection::Bool = false)

    # Define (temporary) objective functions
    _f_Œºz = (F, z) -> Œº(z, y, (1, 2))
    _f_Œºy = (F, y) -> Œº(z, y, (2, 3))

    # Infer sparsity patterns and matrix coloring vector
    sparsity_z, colorvec_z = compute_sparsity_pattern(_f_Œºz, z; sparsity_detection = sparsity_detection)
    sparsity_y, colorvec_y = compute_sparsity_pattern(_f_Œºy, y; sparsity_detection = sparsity_detection)

    #=        # Create caches for the sparse Jacobian methods # This code is left here for when
    jac_cache_Œºz = ForwardColorJacCache(_f_Œºz, z, min(m.Nz, m.Ny); # Jacobians of Œº and Œæ are refactored
    sparsity = sparsity_Œºz, colorvec = colorvec_Œºz)
    jac_cache_Œºy = ForwardColorJacCache(_f_Œºy, y, min(m.Nz, m.Ny);
    sparsity = sparsity_Œºy, colorvec = colorvec_Œºy)=#

    # Create RALF2 objects. Note that we cannot pre-allocate the caches for
    # forwarddiff_color_jacobian! by using ForwardColorJacCache b/c the objective function
    # changes as z and y change. If Jacobians of Œº and Œæ are refactored to be done once,
    # then it'll be possible to cache.
    Œº_dz = similar(z)
    Œº_dy = similar(z)

    Œºz = RALF2((F, z, y) -> forwarddiff_color_jacobian!(F, x -> Œº(x, y, (1, 2)), z, dx = Œº_dz,
                                                        colorvec = colorvec_z, sparsity = sparsity_z),
               z, y, jacobian_type, (Nz, Nz))
    Œºy = RALF2((F, z, y) -> forwarddiff_color_jacobian!(F, x -> Œº(z, x, (2, 3)), y, dx = Œº_dy,
                                                        colorvec = colorvec_y, sparsity = sparsity_y),
               z, y, jacobian_type, (Nz, Ny))

    # Create mini-version of the Jacobian cache
    Œºz_jac_cache = (dx = Œº_dz, sparsity = sparsity_z, colorvec = colorvec_z)
    Œºy_jac_cache = (dx = Œº_dy, sparsity = sparsity_y, colorvec = colorvec_y)

    return Œºz, Œºy, Œºz_jac_cache, Œºy_jac_cache
end

function construct_Œæ_jacobian_function(Œæ::RALF2, z::AbstractVector{<: Number}, y::AbstractVector{<: Number};
                                       sparsity_z::Union{AbstractArray, Nothing} = nothing,
                                       sparsity_y::Union{AbstractArray, Nothing} = nothing,
                                       colorvec_z = nothing, colorvec_y = nothing,
                                       sparsity_detection::Bool = false)

    # Define (temporary) objective functions
    _f_Œæz = (F, z) -> Œæ(z, y, (1, 2))
    _f_Œæy = (F, y) -> Œæ(z, y, (2, 3))

    # Infer sparsity patterns and matrix coloring vector
    sparsity_z, colorvec_z = compute_sparsity_pattern(_f_Œæz, z; sparsity_detection = sparsity_detection)
    sparsity_y, colorvec_y = compute_sparsity_pattern(_f_Œæy, y; sparsity_detection = sparsity_detection)

    #=        # Create caches for the sparse Jacobian methods # This code is left here for when
    jac_cache_Œæz = ForwardColorJacCache(_f_Œæz, z, min(m.Nz, m.Ny);
    sparsity = sparsity_Œæz, colorvec = colorvec_Œæz)
    jac_cache_Œæy = ForwardColorJacCache(_f_Œæy, y, min(m.Nz, m.Ny);
    sparsity = sparsity_Œæy, colorvec = colorvec_Œæy)=#

    # Create RALF2 objects. Note that we cannot pre-allocate the caches for
    # forwarddiff_color_jacobian! by using ForwardColorJacCache b/c the objective function
    # changes as z and y change. If Jacobians of Œº and Œæ are refactored to be done once,
    # then it'll be possible to cache.
    Œæ_dz = similar(y)
    Œæ_dy = similar(y)

    Œæz = RALF2((F, z, y) -> forwarddiff_color_jacobian!(F, x -> Œæ(x, y, (1, 2)), z, dx = Œæ_dz,
                                                        colorvec = colorvec_z, sparsity = sparsity_z),
               z, y, jacobian_type, (Ny, Nz))
    Œæy = RALF2((F, z, y) -> forwarddiff_color_jacobian!(F, x -> Œæ(z, x, (2, 3)), y, dx = Œæ_dy,
                                                        colorvec = colorvec_y, sparsity = sparsity_y),
               z, y, jacobian_type, (Ny, Ny))

    # Create mini-version of the Jacobian cache
    Œæz_jac_cache = (dx = Œæ_dz, sparsity = sparsity_z, colorvec = colorvec_z)
    Œæy_jac_cache = (dx = Œæ_dy, sparsity = sparsity_y, colorvec = colorvec_y)

    return Œæz, Œæy, Œæz_jac_cache, Œæy_jac_cache
end

function construct_ùí±_jacobian_function(ùí±::RALF2, z::AbstractVector{<: Number}, Œ®::AbstractMatrix{<: Number};
                                       sparsity::Union{AbstractArray, Nothing} = nothing,
                                       colorvec = nothing, sparsity_detection::Bool = false)

    # Define (temporary) objective functions
    _f_ùí±z = (F, z) -> ùí±(z, Œ®, (1, 2))

    # Infer sparsity patterns and matrix coloring vector
    if isnothing(sparsity)
        sparsity, colorvec = compute_sparsity_pattern(_f_ùí±z, z; sparsity_detection = sparsity_detection)
    elseif isnothing(colorvec)
        colorvec = matrix_colors(sparsity)
    end

    # Create RALF2 objects. Note that we cannot pre-allocate the caches for
    # forwarddiff_color_jacobian! by using ForwardColorJacCache b/c the objective function
    # changes as z and y change. If Jacobians of Œº and Œæ are refactored to be done once,
    # then it'll be possible to cache.
    ùí±_dz = similar(Œ®, size(Œ®, 1))

    Jùí± = RALF2((F, z, y) -> forwarddiff_color_jacobian!(F, x -> ùí±(x, Œ®, (1, 2)), z, dx = ùí±_dz,
                                                        colorvec = colorvec, sparsity = sparsity),
               z, Œ®, jacobian_type, (Ny, Nz))

    # Create mini-version of the Jacobian cache
    Jùí±_jac_cache = (dx = ùí±_dz, sparsity = sparsity, colorvec = colorvec)

    return Jùí±, Jùí±_jac_cache
end

function construct_ùí±_jacobian_function(ùí±::RALF4, z::AbstractVector{<: Number}, y::AbstractVector{<: Number},
                                       Œ®::AbstractMatrix{<: Number};
                                       sparsity::Union{AbstractArray, Nothing} = nothing,
                                       colorvec = nothing, sparsity_detection::Bool = false)

    # Define (temporary) objective functions
    _f_ùí±z = (F, z‚Çú) -> ùí±(z‚Çú, y, Œ®, z‚Çú, (4, 2))

    # Infer sparsity patterns and matrix coloring vector
    if isnothing(sparsity)
        sparsity, colorvec = compute_sparsity_pattern(_f_ùí±z, z; sparsity_detection = sparsity_detection)
    elseif isnothing(colorvec)
        colorvec = matrix_colors(sparsity)
    end

    # Create RALF2 objects. Note that we cannot pre-allocate the caches for
    # forwarddiff_color_jacobian! by using ForwardColorJacCache b/c the objective function
    # changes as z and y change. If Jacobians of Œº and Œæ are refactored to be done once,
    # then it'll be possible to cache.
    ùí±_dz = similar(Œ®, size(Œ®, 1))

    Jùí± = RALF3((F, z, y, Œ®) -> forwarddiff_color_jacobian!(F, z‚Çú -> ùí±(z, y, Œ®, z‚Çú, (4, 2)), z, dx = ùí±_dz,
                                                           colorvec = colorvec, sparsity = sparsity),
               z, y, Œ®, jacobian_type, (Ny, Nz))

    # Create mini-version of the Jacobian cache
    Jùí±_jac_cache = (dx = ùí±_dz, sparsity = sparsity, colorvec = colorvec)

    return Jùí±, Jùí±_jac_cache
end

# Helper functions for exploiting sparsity in calls to nlsolve

## Helper function for compute_sparsity_pattern
function infer_objective_function(m::RiskAdjustedLinearization, algorithm::Symbol; q::Float64 = .1)

    f = if algorithm == :deterministic
        (F, x) -> _deterministic_equations(F, x, m)
    elseif algorithm == :relaxation
        (F, x) -> _relaxation_equations(F, x, m, m.Œ®, m[:ùí±_sss])
    elseif algorithm == :homotopy
        if Œõ_eltype(m.nonlinear) <: RALF1 && Œ£_eltype(m.nonlinear) <: RALF1
            (F, x) -> _homotopy_equations1(F, x, m, q)
        else
            (F, x) -> _homotopy_equations2(F, x, m, q)
        end
    end

    return f
end

"""
```
compute_sparsity_pattern(m::RiskAdjustedLinearization, algorithm::Symbol; q::Float64 = .1,
                         sparsity::Union{AbstractArray, Nothing} = nothing,
                         sparsity_detection::Bool = false)
```
calculates the sparsity pattern and matrix coloring vector of the Jacobian
of the nonlinear system of equations for either the deterministic or
stochastic steady state, depending on which `algorithm` is called.

### Keywords
- `q`: step size for homotopy. Should satisfy `0 < q < 1` and is only required to ensure
    that the sparsity pattern is correctly determined when `algorithm = :homotopy`
    and thus the dependence of the entropy `ùí±` on the coefficients `(z, y, Œ®)` matters.
- `sparsity`: sparsity pattern of the Jacobian of the nonlinear system of equations
- `sparsity_detection`: if true, use SparsityDetection.jl to determine the sparsity pattern.
    If false, then the sparsity pattern is determined by using finite differences
    to calculate a Jacobian and assuming any zeros will always be zero.
"""
function compute_sparsity_pattern(m::RiskAdjustedLinearization, algorithm::Symbol; q::Float64 = .1,
                                  sparsity::Union{AbstractArray, Nothing} = nothing,
                                  sparsity_detection::Bool = false)
    @assert algorithm in [:deterministic, :relaxation, :homotopy] "The algorithm must be :deterministic, :relaxation, or :homotopy"
    @assert 1 > q > 0 "The step size q must satisfy 0 < q < 1."

    f = infer_objective_function(m, algorithm; q = q)

    input = algorithm == :homotopy ? vcat(m.z, m.y, vec(m.Œ®)) : vcat(m.z, m.y)
    if isnothing(sparsity)
        sparsity = if sparsity_detection
            jacobian_sparsity(f, similar(input), input)
        else
            jac = similar(input, length(input), length(input))
            FiniteDiff.finite_difference_jacobian!(jac, f, input)
            sparse(jac)
        end
    end
    colorvec = matrix_colors(sparsity)

    return sparsity, colorvec
end

"""
```
preallocate_jac_cache(m::RiskAdjustedLinearization, algorithm::Symbol; q::Float64 = .1,
                      sparsity::Union{AbstractArray, Nothing} = nothing,
                      sparsity_detection::Bool = false)
```
pre-allocates the cache for the Jacobian of the nonlinear system of equations
for either the deterministic or stochastic steady state, depending on which
`algorithm` is called.

### Keywords
- `q`: step size for homotopy. Should satisfy `0 < q < 1` and is only required to ensure
    that the sparsity pattern is correctly determined when `algorithm = :homotopy`
    and thus the dependence of the entropy `ùí±` on the coefficients `(z, y, Œ®)` matters.
- `sparsity`: the sparsity pattern of the Jacobian of the nonlinear system of equations
- `sparsity_detection`: if true, use SparsityDetection.jl to determine the sparsity pattern.
    If false, then the sparsity pattern is determined by using finite differences
    to calculate a Jacobian and assuming any zeros will always be zero.
"""
function preallocate_jac_cache(m::RiskAdjustedLinearization, algorithm::Symbol; q::Float64 = .1,
                               sparsity::Union{AbstractArray, Nothing} = nothing,
                               sparsity_detection::Bool = false)

    sparsity, colorvec = compute_sparsity_pattern(m, algorithm; q = q,
                                                  sparsity = sparsity, sparsity_detection = sparsity_detection)
    input = algorithm == :homotopy ? vcat(m.z, m.y, vec(m.Œ®)) : vcat(m.z, m.y)

    return FiniteDiff.JacobianCache(input, colorvec = colorvec, sparsity = sparsity)
end

function construct_sparse_jacobian_function(m::RiskAdjustedLinearization, f::Function,
                                            algorithm::Symbol, autodiff::Symbol;
                                            sparsity::Union{AbstractArray, Nothing} = nothing,
                                            colorvec = nothing, jac_cache = nothing,
                                            sparsity_detection::Bool = false)

    if isnothing(jac_cache)
        # Create Jacobian function that does not assume the existence of a cache

        if isnothing(sparsity) # No sparsity pattern provided, so need to make one
            sparsity, colorvec = compute_sparsity_pattern(m, algorithm; sparsity = sparsity,
                                                          sparsity_detection = sparsity_detection)
        elseif isnothing(colorvec) # Sparsity pattern, but no colorvec, so apply matrix_colors
            colorvec = matrix_colors(sparsity)
        end

        nlsolve_jacobian! = if autodiff == :forward
            (F, x) -> forwarddiff_color_jacobian!(F, f, x, # homotopy doesn't work with autodiff, so assuming
                                                  ForwardColorJacCache(f, x, min(m.Nz, m.Ny); # only using deterministic/relaxation,
                                                                       colorvec = colorvec, sparsity = sparsity)) # hence the chunk size
        else
            (F, x) -> FiniteDiff.finite_difference_jacobian!(F, f, x; colorvec = colorvec,
                                                             sparsity = sparsity)
        end

        return nlsolve_jacobian!, sparsity
    else
        # Create Jacobian function that assumes the existence of a cache

        nlsolve_jacobian! = if autodiff == :forward
            (F, x) -> forwarddiff_color_jacobian!(F, f, x, jac_cache)
        else
            (F, x) -> FiniteDiff.finite_difference_jacobian!(F, f, x, jac_cache)
        end

        return nlsolve_jacobian!, jac_cache.sparsity
    end
end
